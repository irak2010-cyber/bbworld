# Задание 1

<h2>1.</h2>

**Измерительные методы оценки программ** — это подходы к анализу программного обеспечения (ПО) с использованием количественных метрик и показателей. Они позволяют объективно оценивать различные аспекты ПО, такие как качество, сложность, надежность, производительность и эффективность разработки.

<h3>Основные цели применения измерительных методов:</h3>

1. Оценка качества ПО.
2. Измерение надежности, удобства поддержки, соответствия требованиям.
3. Выявление дефектов и уязвимостей на ранних этапах.
4. Управление процессом разработкиКонтроль сроков и бюджета за счет метрик производительности команды.
5. Оптимизация ресурсов (время, затраты, человеческие ресурсы).
6. Cравнение альтернативВыбор между различными архитектурными решениями или технологиями.
7. Анализ эффективности инструментов и методологий разработки.
8. Прогнозирование и планированиеОценка трудоемкости и сроков выполнения проекта.
9. Предсказание рисков (например, вероятность сбоев).
10. Стандартизация и сертификацияСоответствие международным стандартам (ISO/IEC 25000, CMMI).

<h2>2.</h2>

<h3>Метрики размера</h3>

**Количество строк кода (SLOC – Source Lines of Code)** – измеряет общий объем кода. Используется для оценки трудоемкости разработки, сопровождения и прогнозирования сроков проекта.

**Количество функций/методов** – показывает, сколько функциональных блоков содержит программа. Помогает оценить модульность кода и потенциальную сложность поддержки.

<h3>Метрики сложности</h3>

**Цикломатическая сложность (Cyclomatic Complexity)** – определяет количество линейно независимых путей выполнения в программе. Чем выше значение, тем сложнее код для тестирования и отладки. Используется для выявления потенциально проблемных участков кода.

<h3>Метрики качества</h3>

**Коэффициент сопровождения(Maintainability Index)** – оценивает легкость поддержки кода на основе таких факторов, как сложность, объем кода и комментарии. Чем выше значение, тем проще сопровождать код.

**Покрытие тестами (Test Coverage)** – показывает процент кода, проверяемого автоматическими тестами. Используется для оценки надежности и качества тестирования.

<h2>3.</h2>

<h3>Метрики используются для:</h3>

1. **Оценки качества кода** – выявления сложных, плохо поддерживаемых или ненадежных участков.  
2. **Прогнозирования трудозатрат** – оценки времени на разработку, тестирование и исправление ошибок.  
3. **Сравнения альтернативных решений** – выбора более эффективных архитектур или алгоритмов.  
4. **Контроля технического долга** – мониторинга ухудшения кодовой базы со временем.  
5. **Улучшения процессов тестирования** – определения недостаточно покрытых тестами модулей.  
6. **Принятия управленческих решений** – обоснования необходимости рефакторинга, найма новых разработчиков или смены технологий.  

<h3>Ограничения измерительных методов</h3>

1. **Неполнота данных** – метрики не всегда отражают реальную сложность или качество (например, не учитывают бизнес-логику).
2. **Ложные выводы** – высокое покрытие тестами не гарантирует отсутствие багов, а низкая цикломатическая сложность не всегда означает хороший код.
3. **Зависимость от контекста** – одни и те же значения метрик могут быть приемлемыми в одном проекте и критичными в другом.
4. **Игнорирование человеческого фактора** – не учитывают опыт разработчиков, командную динамику и субъективное восприятие кода.
5. **Возможность манипуляции** – разработчики могут искусственно улучшать метрики (например, разбивать код на мелкие функции для снижения цикломатической сложности без реального упрощения логики).
6. **Перекос в сторону количественных показателей** – чрезмерное внимание к метрикам может привести к оптимизации "для галочки" в ущерб реальному качеству.

# Задание 2

<h2>Теоретическая часть</h2>

Метрики размера включают количество строк кода (SLOC), где учитываются только исполняемые строки без пустых и комментариев, а также количество функций в коде.

Для оценки сложности кода используется цикломатическая сложность. Она показывает количество независимых путей выполнения в функции и рассчитывается как число ветвлений (условий, циклов) плюс 1. Чем выше значение, тем сложнее код и выше вероятность ошибок.

Анализ показал, что самая сложная функция определяется по наибольшей цикломатической сложности. Потенциальные места для ошибок включают сложные функции, отсутствие обработки исключений и неочевидные условия.

<h2>Практическая часть</h2>

<h3>Анализ файла test1.py:</h3>

Количество строк кода (SLOC): 85

Количество функций: 0 (код выполняется последовательно)

Цикломатическая сложность основного блока: ~5 из-за вложенных условий и циклов

<h3>Анализ файла test2.py:</h3>

Количество строк кода (SLOC): 12

Количество функций: 3 (calculate_sum, factorial, print_numbers)

Цикломатическая сложность функций:

calculate_sum: 1 (нет ветвлений)

factorial: 2 (одно условие)

print_numbers: 3 (цикл и условие)

<h3>Выводы:</h3>

Самая сложная функция - print_numbers из test2.py (сложность 3). В  test1.py потенциальные ошибки могут возникнуть из-за отсутствия обработки исключений при запросах. В test2.py функция factorial не проверяет отрицательные числа, что может привести к бесконечной рекурсии.

<h3>Рекомендации по улучшению:</h3>

<h4>Для test1.py:</h4>

Разделить код на отдельные функции

Добавить обработку исключений

Использовать константы для настроек

<h4> Для test2.py:</h4>
  
Добавить проверку на отрицательные числа в factorial

Проверять входные значения в print_numbers
